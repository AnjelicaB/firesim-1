#!/usr/bin/env bash

# FireSim initial setup script. Under FireSim-as-top this script will:
# 1) Initalize submodules (only the required ones, minimizing duplicates
# 2) Install RISC-V tools, including linux tools
# 3) Installs python requirements for firesim manager

# Under library mode, (2) is skipped.

# TODO: build FireSim linux distro here?

# exit script if any command fails
set -e
set -o pipefail

unamestr=$(uname)
RDIR=$(pwd)

FASTINSTALL=false
IS_LIBRARY=false
SKIP_TOOLCHAIN=false
SKIP_VALIDATE=false

function usage
{
    echo "usage: build-setup.sh [ fast | --fast] [--skip-toolchain] [--library] [--skip-validate]"
    echo "   fast: if set, pulls in a pre-compiled RISC-V toolchain for an EC2 manager instance"
    echo "   skip-toolchain: if set, skips RISC-V toolchain handling (cloning or building)."
    echo "                   The user must define $RISCV in their env to provide their own toolchain."
    echo "   library: if set, initializes submodules assuming FireSim is being used"
    echo "            as a library submodule. Implies --skip-toolchain "
    echo "   skip-validate: if set, skips checking if user is on release tagged branch"
}

if [ "$1" == "--help" -o "$1" == "-h" -o "$1" == "-H" ]; then
    usage
    exit 3
fi

while test $# -gt 0
do
   case "$1" in
        fast | --fast) # I don't want to break this api
            FASTINSTALL=true
            ;;
        --library)
            IS_LIBRARY=true;
            SKIP_TOOLCHAIN=true;
            ;;
        --skip-toolchain)
            SKIP_TOOLCHAIN=true;
            ;;
        --skip-validate)
            SKIP_VALIDATE=true;
            ;;
        -h | -H | --help)
            usage
            exit
            ;;
        --*) echo "ERROR: bad option $1"
            usage
            exit 1
            ;;
        *) echo "ERROR: bad argument $1"
            usage
            exit 2
            ;;
    esac
    shift
done

# before doing anything verify that you are on a release branch/tag
set +e
tag=$(git describe --exact-match --tags)
tag_ret_code=$?
set -e
if [ $tag_ret_code -ne 0 ]; then
    if [ "$SKIP_VALIDATE" = false ]; then
        read -p "WARNING: You are not on an official release of FireSim."$'\n'"Type \"y\" to continue if this is intended, otherwise see https://docs.fires.im/en/stable/Initial-Setup/Setting-up-your-Manager-Instance.html#setting-up-the-firesim-repo: " validate
        [[ $validate == [yY] ]] || exit 5
        echo "Setting up non-official FireSim release"
    fi
else
    echo "Setting up official FireSim release: $tag"
fi

if [ "$SKIP_TOOLCHAIN" = true ]; then
    if [ -z "$RISCV" ]; then
        echo "ERROR: You must set the RISCV environment variable before running"
        echo "firesim/$0 if running under --library or --skip-toolchain."
        exit 4
    else
        echo "Using existing RISCV toolchain at $RISCV"
    fi
else
    RISCV=$(pwd)/riscv-tools-install
    export RISCV=$RISCV
    echo "Installing fresh RISCV toolchain to $RISCV"
fi

# Remove and backup the existing env.sh if it exists
# The existing of env.sh implies this script completely correctly
if [ -f env.sh ]; then
    mv -f env.sh env.sh.backup
fi


# This will be flushed out into a complete env.sh which will be written out
# upon completion.
env_string="# This file was generated by $0"

function env_append {
    env_string+=$(printf "\n$1")
}

# Initially, create a env.sh that suggests build.sh did not run correctly.
bad_env="${env_string}
echo \"ERROR: build-setup.sh did not execute correctly or was terminated prematurely.\"
echo \"Please review build-setup-log for more information.\"
return 1"
echo "$bad_env" > env.sh


read -r -d '\0' SOURCE_ONCE_CHECK <<'END_CHECK'
while test $# -gt 0
do
   case "$1" in
        --skip-validate)
            SKIP_VALIDATE=true;
            ;;
        *) echo "Unknown argument $1"
	         ;;
   esac
   shift
done
if [[ "${FIRESIM_ENV_SOURCED:-zzz}" != zzz  && "$SKIP_VALIDATE" != true ]]; then 
    read -p $'WARNING: You have already sourced a firesim env. Type "y" to continue if this is intended, otherwise please use a new shell ' validate
    [[ "$validate" == [yY] ]] || return 5
fi

export FIRESIM_ENV_SOURCED=1
\0
END_CHECK
env_append "$SOURCE_ONCE_CHECK"


git config submodule.target-design/chipyard.update none
git submodule update --init --recursive #--jobs 8

if [ "$IS_LIBRARY" = false ]; then
    # This checks if firemarshal has already been configured by someone. If
    # not, we will provide our own config. This must be checked before calling
    # init-submodules-no-riscv-tools.sh because that will configure
    # firemarshal.
    marshal_cfg=$RDIR/target-design/chipyard/software/firemarshal/marshal-config.yaml
    if [ ! -f $marshal_cfg ]; then
      first_init=true
    else
      first_init=false
    fi

    git config --unset submodule.target-design/chipyard.update
    git submodule update --init target-design/chipyard
    cd $RDIR/target-design/chipyard
    ./scripts/init-submodules-no-riscv-tools.sh --skip-validate
    cd $RDIR

    # Configure firemarshal to know where our firesim installation is.
    # If this is a fresh init of chipyard, we can safely overwrite the marshal
    # config, otherwise we have to assume the user might have changed it
    if [ $first_init = true ]; then
      echo "firesim-dir: '../../../../'" > $marshal_cfg
    fi
    env_append "export FIRESIM_STANDALONE=1"
fi

# FireMarshal Setup
if [ "$IS_LIBRARY" = true ]; then
    target_chipyard_dir=$RDIR/../..

    # setup marshal symlink
    ln -sf ../../../software/firemarshal $RDIR/sw/firesim-software
else
    target_chipyard_dir=$RDIR/target-design/chipyard

    # setup marshal symlink
    ln -sf ../target-design/chipyard/software/firemarshal $RDIR/sw/firesim-software
fi

# RISC-V Toolchain Compilation
# When FireSim is being used as a library, the user is expected to build their
# own toolchain. For FireSim-as-top, call out to Chipyard's toolchain scripts.
if [ "$SKIP_TOOLCHAIN" != true ]; then
    # Restrict the devtoolset environment to a subshell
    #
    # The devtoolset wrapper around sudo does not correctly pass options
    # through, which causes an aws-fpga SDK setup script to fail:
    # platforms/f1/aws-fpga/sdk/userspace/install_fpga_mgmt_tools.sh
    (
        # Enable latest Developer Toolset for GNU make 4.x
        devtoolset=''
        for dir in /opt/rh/devtoolset-* ; do
            ! [ -x "${dir}/root/usr/bin/make" ] || devtoolset="${dir}"
        done
        if [ -n "${devtoolset}" ] ; then
            echo "Enabling ${devtoolset##*/}"
            . "${devtoolset}/enable"
        fi

	# chipyards build-toolchains.sh make defaults to gnumake or gmake but we 
	# have latest make installed as make
	export MAKE=make

        # Build the toolchain through chipyard (whether as top or as library)
        cd "$target_chipyard_dir"
        if [ "$FASTINSTALL" = "true" ] ; then
            MAKE=make ./scripts/build-toolchains.sh ec2fast
        else
            MAKE=make ./scripts/build-toolchains.sh
        fi
    )
    source "$target_chipyard_dir/env.sh"
    env_append "source $target_chipyard_dir/env.sh"
fi

cd $RDIR

# commands to run only on EC2
# see if the instance info page exists. if not, we are not on ec2.
# this is one of the few methods that works without sudo
if wget -T 1 -t 3 -O /dev/null http://169.254.169.254/; then
    cd "$RDIR/platforms/f1/aws-fpga/sdk/linux_kernel_drivers/xdma"
    make

    # Install firesim-software dependencies
    # We always setup the symlink correctly above, so use sw/firesim-software
    marshal_dir=$RDIR/sw/firesim-software
    # the only ones missing are libguestfs-tools
    sudo yum install -y libguestfs-tools bc

    # Setup for using qcow2 images
    # XXX skip this for now because it needs rpmbuild and other things from the Development Tools  group
    #cd $RDIR
    #./scripts/install-nbd-kmod.sh

    (
	if [[ "${CPPFLAGS:-zzz}" != "zzz" ]]; then
	    # don't set it if it isn't already set but strip out -DNDEBUG because
	    # the sdk software has assertion-only variable usage that will end up erroring
	    # under NDEBUG with -Wall and -Werror
	    export CPPFLAGS="${CPPFLAGS/-DNDEBUG/}"
	fi


	# Source {sdk,hdk}_setup.sh once on this machine to build aws libraries and
	# pull down some IP, so we don't have to waste time doing it each time on
	# worker instances
	AWSFPGA=$RDIR/platforms/f1/aws-fpga
	cd $AWSFPGA
	bash -c "source ./sdk_setup.sh"
	bash -c "source ./hdk_setup.sh"
    )
fi

# Per-repository dependencies are installed under this sysroot
firesim_local_sysroot=$RDIR/sim/lib-install
cd $RDIR
mkdir -p $firesim_local_sysroot
./scripts/build-libelf.sh $firesim_local_sysroot
./scripts/build-libdwarf.sh $firesim_local_sysroot
env_append "export LD_LIBRARY_PATH=$firesim_local_sysroot/lib\${LD_LIBRARY_PATH:+\":\${LD_LIBRARY_PATH}\"}"

cd $RDIR
set +e
./gen-tags.sh
set -e



read -r -d '\0' NDEBUG_CHECK <<'END_NDEBUG'
# Ensure that we don't have -DNDEBUG anywhere in our environment

# check and fixup the known place where conda will put it
if [[ "$CPPFLAGS" == *"-DNDEBUG"* ]]; then
    echo "::INFO:: removing '-DNDEBUG' from CPPFLAGS as we prefer to leave assertions in place"
    export CPPFLAGS="${CPPFLAGS/-DNDEBUG/}"
fi

# XXX generalize the /opt/conda path and/or possibly capture the conda environment in use here
# set FLAGS to minimal set of ones that are needed to make things work with conda
export LDFLAGS="-Wl,-rpath,/opt/conda/lib -Wl,-rpath-link,/opt/conda/lib -L/opt/conda/lib"
export CXXFLAGS="-isystem /opt/conda/include"
export CFLAGS="-isystem /opt/conda/include"
unset CPPFLAGS

# check for any other occurances and warn the user
env | grep -- -DNDEBUG && echo "::WARNING:: you still seem to have -DNDEBUG in your environment. This is known to cause problems."
true # ensure env.sh exits 0
\0
END_NDEBUG
env_append "$NDEBUG_CHECK"

# original conda flags that cause failures in midas tests
#LDFLAGS=-Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,--allow-shlib-undefined -Wl,-rpath,/opt/conda/lib -Wl,-rpath-link,/opt/conda/lib -L/opt/conda/lib
#CXXFLAGS=-fvisibility-inlines-hidden -std=c++17 -fmessage-length=0 -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /opt/conda/include
#CFLAGS=-march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /opt/conda/include
#CPPFLAGS= -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /opt/conda/include


# Write out the generated env.sh indicating successful completion.
echo "$env_string" > env.sh

echo "Setup complete!"
echo "To generate simulator RTL and run sw-RTL simulation, source env.sh"
echo "To use the manager to deploy builds/simulations on EC2, source sourceme-f1-manager.sh to setup your environment."
echo "To run builds/simulations manually on this machine, source sourceme-f1-full.sh to setup your environment."
